---
title: "Tackling gotchas: Refactoring code from a script to a package"
author: Mauro Lepore
output:
  github_document:
    toc: true
    toc_depth: 2
---

```{r setup}
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  error = TRUE,
  collapse = TRUE
)
```

# Motivation

> You and a friend are having a picnic by the side of a river. Suddenly you hear a shout from the direction of the waterâ€”a child is drowning. Without thinking, you both dive in, grab the child, and swim to shore. Before you can recover, you hear another child cry for help. You and your friend jump back in the river to rescue her as well. Then another struggling child drifts into sight ... and another ... and another. The two of you can barely keep up. Suddenly, you see your friend wading out of the water, seeming to leave you alone. "Where are you going?" you demand. Your friend answers, "I'm going Nopetream to tackle the guy who's throwing all these kids in the water.'

-- Irving Zola's parable adapted by Dan Heath, author of "Nopetream: The Quest to Solve Problems Before They Happen" (coming out 2020-03-03).

--

<img src="https://4f0imd322ifhg1y4zfwk3wr7-wpengine.netdna-ssl.com/wp-content/uploads/2017/06/NoThanksButWereBusy.png" align="center" width = 750 />

["No Thanks, We're Too Busy".](https://www.astroarch.com/tvp_strategy/no-thanks-busy-pay-back-technical-debt-40188/)



## What is a gotcha?

*Code that is valid in a script but invalid or unexpected in a package.*

-- Adapted from <https://en.wikipedia.org/wiki/Gotcha_(programming)>



## What is refactoring code?

*Restructuring code without changing its external behavior.*

-- Adapted from <https://en.wikipedia.org/wiki/Code_refactoring>



# Function interface

## Avoid relying on the global environment

Good.

```{r}
f <- function(data) {
  data
}

my_data <- tibble::tibble(x = 1)
f(my_data)
```

Bad. 

```{r}
f <- function(data = my_data2) {
  data
}

ls()
try(f())

my_data2 <- tibble::tibble(x = 1)
ls()
f()
```



## Avoid modifying the global environment, e.g. with `<<-`

Setup.

```{r}
readr::write_csv(mtcars, "some_data.csv")
```

Good.

```{r}
some_data_path <- function() {
  fs::path("some_data.csv")
}

some_data_path()

read_some_data <- function(path) {
  suppressMessages(head(readr::read_csv(path)))
}

path <- some_data_path()  # Define path
read_some_data(path)
```

Bad.

```{r}
some_data_path <- function() {
  path <<- "some_data.csv"
}

read_some_data <- function() {
  suppressMessages(head(readr::read_csv(path)))
}

some_data_path()  # Define path
read_some_data()
```

> "[Avoid global variables because they] introduce non-obvious dependencies between functions" -- [Advanced R, Environments](https://adv-r.hadley.nz/environments.html)). 

For valid uses of `<<-` see ([Advanced R, Function factories](https://adv-r.hadley.nz/function-factories.html#stateful-funs)).

Clean up.

```{r}
fs::file_delete("some_data.csv")
```

## Arguments that provide core data are required

Good.

```R
f <- function(data) {
  data
}

f(mtcars)
```

Bad.

```R
f <- function(data = mtcars) {
  data
}

f()
```

> Arguments that provide core data are required (have no default); they are often called `data`, `x`, or `y`).

-- Adapted from <https://principles.tidyverse.org/args-data-details.html>



## Descriptor arguments are usually required

Good.

```R
forecast <- function(data, start_year, time_span = 5) {
  end_year <- start_year + time_span
  time_period <- data$year >= start_year & data$year <= end_year
  
  data %>%
    filter(time_period) %>%
    # ...
}
```

Bad.

```R
forecast <- function(data, start_year = 2020, time_span = 5) {
  # ...
}
```

> Descriptor arguments describe essential details of the operation, and are usually required.

-- Adapted from <https://principles.tidyverse.org/args-data-details.html>



## Avoid reading and writing operations

Unless it is precisely the purpose of your function, avoid operations that read or write data (in general, avoid side effects).

Good. 

```R
f <- function(data) {
  dplyr::select(data, 1L)
}
```

Bad.

```R
f <- function(path) {
  data <- readxl::read_excel(path)
  dplyr::select(data, 1L)
}
```

* [What is a pure function](https://github.com/2DegreesInvesting/resources/issues/68).
* [Avoid hidden arguments  (ds-incubator)](https://github.com/2DegreesInvesting/ds-incubator/blob/master/2019-12-03_avoid-hidden-arguments.pdf).



# Packaging

## Developer setup

```R
library(usethis)
library(devtools)
```

Maybe edit your .Rprofile.

```R
edit_r_profile()
```



## `use_package("dplyr")` not `library(dplyr)`

Good.

```R
use_package("dplyr")
```

Bad.

```R
library(dplyr)
```

<https://r-pkgs.org/whole-game.html>



## The tidyverse is for EDA, not packages

Good.

```R
use_package("dplyr")
use_package("tidyr")
```

Bad.

```R
use_package("tidyverse")
```

<https://www.tidyverse.org/blog/2018/06/tidyverse-not-for-packages/>



## `use_data_raw()`, then `use_data()`

Good.

```R
# > Console
use_data_raw()

# data-raw/dataset-name.R
dataset_name <- readxl::read_excel("data-raw/dataset-name.xlsx")
use_data(dataset_name)

# R/dataset_name.R
#' A dataset
#' 
"dataset_name"

# R/any-file.R
f <- function() {
  dataset_name
}
```

## `use_data_raw()`, then `use_data()`

Bad.

```R
# R/any-file.R
dataset_name <- readxl::read_excel("data/dataset-name.xlsx")

f <- function() {
  dataset_name
}
```

<http://r-pkgs.had.co.nz/data.html>






## Use the `.data` pronoun

Good.

```R
f <- function(data, column_name) {
  dplyr::select(data, .data[[column_name]])
}
```

Ok.

```R
f <- function(data) {
  stopifnot(hasName(mtcars, "cyl"))
  
  dplyr::select(data, .data$cyl)
}
```


Bad. 

```R
f <- function(data) {
  dplyr::select(data, cyl)
}
```

<https://rlang.r-lib.org/reference/tidyeval-data.html>



## Consider using internal data

Good.

```R
# data-raw/my_internal_data.R
use_data(my_internal_data, internal = TRUE)

# R/any.R
f <- function(data) {
  dplyr::left_join(data, my_internal_data)
}
```

Bad.

```R
# R/any.R
my_internal_data <- mtcars %>% dplyr::select(cyl)

f <- function(data) {
  dplyr::left_join(data, my_internal_data)
}
```

<http://r-pkgs.had.co.nz/data.html#data-sysdata>



# Code smells and feels

## Simplify `if()` with objects named meaningfully

```{r}
x <- sample(c(1:10), size = 2, replace = TRUE)
say <- function(x, msg) paste(paste(x, collapse = ", "), msg)
say(1:2, "Hey!")
```

Good.

```{r}
is_even_between_5and10 <- (x %% 2 == 0) & dplyr::between(x, 5L, 10L)
if (all(is_even_between_5and10)) {
  say(x, "Yeah!")
} else {
  say(x, "Nope!")
}
```

Bad.

```{r}
if (all((x %% 2 == 0) & (x >= 5L) & (x <= 10L))) {
  say(x, "Yeah!")
} else {
  say(x, "Nope!")
}
```

<https://speakerdeck.com/jennybc/code-smells-and-feels?slide=36>



## Program for columns with `clean_names`

Good.

```{r}
f <- function(data) {
  clean <- r2dii.utils::clean_column_names(data)
  
  stopifnot(hasName(clean, "a_column"))
  result <- dplyr::select(clean, .data$a_column)
  
  r2dii.utils::unclean_column_names(result, data)
}

f(tibble::tibble(A.Column = 1, Another.Column = 1))
```

Bad.

```{r}
f <- function(data) {
  dplyr::select(data, .data$A.Column)
}

f(tibble::tibble(A.Column = 1, Another.Column = 1))
```

[`?clean_column_names()`](https://2degreesinvesting.github.io/r2dii.utils/reference/clean_column_names.html)



## Avoid long-running temporary objects

Avoid temporary variables unless they run for only a few, consecutive lines.

Good.

```R
tmp <- dplyr::filter(mtcars, cyl > 4)
tmp <- dplyr::select(tmp, disp)
tmp <- head(tmp)

# ... more unrelated code
```

Better.

```R
mtcars %>% 
  dplyr::filter(cyl > 4) %>% 
  dplyr::select(disp) %>% 
  head()
```

Bad.

```R
tmp <- dplyr::filter(mtcars, cyl > 4)
tmp <- dplyr::select(tmp, disp)

# ... more unrelated code (makes your forget what `tmp` holds)

tmp <- head(tmp)
```

## If possible, extract functions to the top level

Good.

```{r}
f <- function(x) {
  g(x)
}

g <- function(x) {
  x + 1
}
```

Bad.

```{r}
f <- function(x) {
  g <- function(x) {
    x + 1
  }
  
  g(x)
}
```

## Extract commented sections into functions

Good.

```R
f <- function(x) {
  y <- calculate_y(x)
  
  # ... more code
}

calculate_y <- function(x) {
  x^x * x/2L
  # ... more code specifically about calculating y
}
```

Bad.

```R
f <- function(x) {
  # calculate y
  y <- x^x * x/2L
  # ... more code specifically about calculating y
  
  # ... more code
}
```



# Error prone

## Separate functions, data, and scripts

### A non-package project

It's easy for an analyst to maintain a project when functions, data, and scripts are separate.

Good.

```R
# R/all-functions.R
f <- function(data) {
  # ... some code
}

# data/all-datasets.R
some_data <- readr::read_csv(here::here("data-raw", "some_data.csv"))

# script/this-script.R
library(tidyverse)

source(here::here("R", "all-functions.R"))
source(here::here("data", "all-datasets.R"))


f(data = some_data)
```

It is error prone to mix functions, data, and scripts. The mess hides inter dependencies that can break your code unexpectedly. Also, this makes it hard for others to reproduce, or understand your code -- [the maintainance programmer can only view your code through a toilet paper tube](https://github.com/2DegreesInvesting/resources/issues/38#issuecomment-576383067).

Bad.

```R
# sripts-functions-and-data.R
library(tidyverse)

some_data <- readr::read_csv(here::here("data-raw", "some_data.csv"))

f <- function(some_data) {
  some_data %>% 
    dplyr::select() %>% 
    # ... more code
}

f(some_data)
```

### A package project

When functions, data, and scripts are separate, it's easy for a developer to transform a project into an R package. Functions go in the R/ directory, raw data in data-raw/, and data in data/. Scripts become examples, tests, and higher level documentation such as README, and the Home and articles pages of the package-website.

## `if()` uses a single `TRUE` or `FALSE`

```{r}
x <- c(1, 2)
y <- 0L
```

Good

```{r}
# Good
if (identical(x, c(1, 2))) {
  say(identical(x, c(1, 2)), "is what you gave.")
}
```

```{r}
# Bad
if (x == c(1, 2)) {
  say(x == c(1, 2), "is what you gave.")
}
```

Caveats: <https://github.com/2DegreesInvesting/ds-incubator/issues/13>



## `1` is equal to `1L` but not identical

Careful!

```{r}
1 == 1L
identical(1, 1L)

```

Good

```{r}
this_integer <- 1L
if (!identical(this_integer, 1)) "Not the same" else "Wrong result"
```

Bad.

```{r}
this_integer <- 1L
if (!this_integer == 1) "Not the same" else "Wrong result"
```



# Style

## Limit your code to 80 characters per line

For reference, in RStdio you can set a margin column at 80 characters (_Tools > Global Options > Code > Show margin > Margin column_).

> Strive to limit your code to 80 characters per line. This fits comfortably on a printed page with a reasonably sized font. If you find yourself running out of room, this is a good indication that you should encapsulate some of the work in a separate function.

-- <https://style.tidyverse.org/syntax.html#long-lines>

> If a function definition runs over multiple lines, indent the second line to where the definition starts.

-- <https://style.tidyverse.org/functions.html#long-lines-1>



## Names should use only lowercase letters, numbers, and "_".

* Generally, variable names should be nouns and function names should be verbs. 
* Strive for names that are concise and meaningfully!
* Reserve dots exclusively for the S3 object system.

Good.

```R
add_row()
permute()
```

Bad.

```R
row_adder()
permutation()
```

* <https://style.tidyverse.org/syntax.html#object-names>
* <https://style.tidyverse.org/functions.html#naming>



## Avoid `T` and `F` as synonyms for `TRUE` and `FALSE`

Good

```R
sum(1, 1, na.rm = TRUE)
```

Bad.

```R
sum(1, 1, na.rm = T)
```

`TRUE` and `FALSE` are reserved words; `T` and `F` are not.

```{r}
T <- "Whatever"
T

# Forbidden
try(TRUE <- "Whatever")
```

<https://www.r-bloggers.com/r-tip-avoid-using-t-and-f-as-synonyms-for-true-and-false/>



## Reserve `return()` to return early

> Only use `return()` for early returns. Otherwise, rely on R to return the result of the last evaluated expression

<https://style.tidyverse.org/functions.html#return>



