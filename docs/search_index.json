[
["gotchas-when-moving-code-from-a-script-to-an-r-package.html", "Gotchas when moving code from a script to an R package 15.4 Packaging 15.5 Function interface 15.6 Code smells and feels 15.7 Error prone 15.8 Style", " Gotchas when moving code from a script to an R package 15.4 Packaging 15.4.1 Setup: R, RStudio, Git, GitHub These steps will direct you to relevant chapters from “Happy Git with R” by Jenny Bryan et. al. Register a free GitHub account Install or update R and RStudio Install Git Introduce yourself to Git Prove local Git can talk to GitHub Cache your username and password or set up SSH keys Create and save a GitHub Personal Access Token (PAT) Prove RStudio can find local Git and, therefore, can talk to GitHub 15.4.2 Setup: devtools and testthat Make the devtools and testthat packages available in every R session. Edit your .Rprofile file to include this code (you may use usethis::edit_r_profile()): if (interactive()) { suppressMessages(require(devtools)) suppressMessages(require(testthat)) } (Your .Rprofile should NOT include data analysis packages such as dplyr or ggplot2.) Ensure you always start each session with a blank slate: Save, close and restart R. 15.4.3 use_data_raw(), then use_data() Good. # &gt; Console use_data_raw() # data-raw/dataset-name.R dataset_name &lt;- readxl::read_excel(&quot;data-raw/dataset-name.xlsx&quot;) use_data(dataset_name) # R/dataset_name.R #&#39; A dataset #&#39; &quot;dataset_name&quot; # R/any-file.R f &lt;- function() { dataset_name } Bad. # R/any-file.R dataset_name &lt;- readxl::read_excel(&quot;data/dataset-name.xlsx&quot;) f &lt;- function() { dataset_name } Bad. f &lt;- function() { load(&quot;data/dataset_name.rda&quot;) } http://r-pkgs.had.co.nz/data.html 15.4.4 Consider using internal data Good. # data-raw/my_internal_data.R use_data(my_internal_data, internal = TRUE) # R/any.R f &lt;- function(data) { dplyr::left_join(data, my_internal_data) } Bad. # R/any.R my_internal_data &lt;- mtcars %&gt;% dplyr::select(cyl) f &lt;- function(data) { dplyr::left_join(data, my_internal_data) } http://r-pkgs.had.co.nz/data.html#data-sysdata 15.4.5 use_package(\"dplyr\") not library(dplyr) Good. use_package(&quot;dplyr&quot;) Bad. library(dplyr) https://r-pkgs.org/whole-game.html 15.4.6 namespace::function_from_other_package() Good. f &lt;- function(data) { utils::head(dplyr::select(data, dplyr::last_col())) } Good. #&#39; @importFrom magrittr %&gt;% #&#39; @importFrom utils head #&#39; @importFrom dplyr select last_col f &lt;- function(data) { data %&gt;% select(last_col()) %&gt;% head() } Bad. f &lt;- function(data) { head(select(data, last_col())) } Bad. f &lt;- function(data) { data %&gt;% select(last_col()) %&gt;% head() } 15.4.7 The tidyverse is for EDA, not packages Good. use_package(&quot;dplyr&quot;) use_package(&quot;tidyr&quot;) Bad. use_package(&quot;tidyverse&quot;) https://www.tidyverse.org/blog/2018/06/tidyverse-not-for-packages/ 15.4.8 Use the .data pronoun Good. f &lt;- function(data, column_name) { dplyr::select(data, .data[[column_name]]) } Ok. f &lt;- function(data) { stopifnot(hasName(mtcars, &quot;cyl&quot;)) dplyr::select(data, .data$cyl) } Bad. f &lt;- function(data) { dplyr::select(data, cyl) } https://rlang.r-lib.org/reference/tidyeval-data.html 15.5 Function interface 15.5.1 Avoid relying on the global environment Good. f &lt;- function(data) { data } my_data &lt;- tibble::tibble(x = 1) f(my_data) #&gt; # A tibble: 1 x 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 1 Bad. f &lt;- function(data = my_data2) { data } ls() #&gt; [1] &quot;f&quot; &quot;my_data&quot; try(f()) #&gt; Error in f() : object &#39;my_data2&#39; not found my_data2 &lt;- tibble::tibble(x = 1) ls() #&gt; [1] &quot;f&quot; &quot;my_data&quot; &quot;my_data2&quot; f() #&gt; # A tibble: 1 x 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 1 15.5.2 Avoid modifying the global environment, e.g. with &lt;&lt;- Setup. readr::write_csv(mtcars, &quot;some_data.csv&quot;) Good. some_data_path &lt;- function() { fs::path(&quot;some_data.csv&quot;) } some_data_path() #&gt; some_data.csv read_some_data &lt;- function(path) { suppressMessages(head(readr::read_csv(path))) } path &lt;- some_data_path() # Define path read_some_data(path) #&gt; # A tibble: 6 x 11 #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 Bad. some_data_path &lt;- function() { path &lt;&lt;- &quot;some_data.csv&quot; } read_some_data &lt;- function() { suppressMessages(head(readr::read_csv(path))) } some_data_path() # Define path read_some_data() #&gt; # A tibble: 6 x 11 #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 “[Avoid global variables because they] introduce non-obvious dependencies between functions” – Advanced R, Environments). For valid uses of &lt;&lt;- see (Advanced R, Function factories). Clean up. fs::file_delete(&quot;some_data.csv&quot;) 15.5.3 Arguments that provide core data are required Good. f &lt;- function(data) { data } f(mtcars) Bad. f &lt;- function(data = mtcars) { data } f() Arguments that provide core data are required (have no default); they are often called data, x, or y). – Adapted from https://principles.tidyverse.org/args-data-details.html 15.5.4 Descriptor arguments are usually required Good. forecast &lt;- function(data, start_year, time_span = 5) { end_year &lt;- start_year + time_span time_period &lt;- data$year &gt;= start_year &amp; data$year &lt;= end_year data %&gt;% filter(time_period) %&gt;% # ... } Bad. forecast &lt;- function(data, start_year = 2020, time_span = 5) { # ... } Descriptor arguments describe essential details of the operation, and are usually required. – Adapted from https://principles.tidyverse.org/args-data-details.html 15.5.5 Avoid reading and writing operations Unless it is precisely the purpose of your function, avoid operations that read or write data (in general, avoid side effects). Good. f &lt;- function(data) { dplyr::select(data, 1L) } Bad. f &lt;- function(path) { data &lt;- readxl::read_excel(path) dplyr::select(data, 1L) } What is a pure function. Avoid hidden arguments (ds-incubator). 15.6 Code smells and feels 15.6.1 Simplify if() with objects named meaningfully x &lt;- sample(c(1:10), size = 2, replace = TRUE) say &lt;- function(x, msg) paste(paste(x, collapse = &quot;, &quot;), msg) say(1:2, &quot;Hey!&quot;) #&gt; [1] &quot;1, 2 Hey!&quot; Good. is_even_between_5and10 &lt;- (x %% 2 == 0) &amp; dplyr::between(x, 5L, 10L) if (all(is_even_between_5and10)) { say(x, &quot;Yeah!&quot;) } else { say(x, &quot;Nope!&quot;) } #&gt; [1] &quot;6, 1 Nope!&quot; Bad. if (all((x %% 2 == 0) &amp; (x &gt;= 5L) &amp; (x &lt;= 10L))) { say(x, &quot;Yeah!&quot;) } else { say(x, &quot;Nope!&quot;) } #&gt; [1] &quot;6, 1 Nope!&quot; https://speakerdeck.com/jennybc/code-smells-and-feels?slide=36 15.6.2 Program for columns with clean_names Good. f &lt;- function(data) { clean &lt;- r2dii.utils::clean_column_names(data) stopifnot(hasName(clean, &quot;a_column&quot;)) result &lt;- dplyr::select(clean, .data$a_column) r2dii.utils::unclean_column_names(result, data) } f(tibble::tibble(A.Column = 1, Another.Column = 1)) #&gt; # A tibble: 1 x 1 #&gt; A.Column #&gt; &lt;dbl&gt; #&gt; 1 1 Bad. f &lt;- function(data) { dplyr::select(data, .data$A.Column) } f(tibble::tibble(A.Column = 1, Another.Column = 1)) #&gt; # A tibble: 1 x 1 #&gt; A.Column #&gt; &lt;dbl&gt; #&gt; 1 1 ?clean_column_names() 15.6.3 Avoid long-running temporary objects Avoid temporary variables unless they run for only a few, consecutive lines. Good. tmp &lt;- dplyr::filter(mtcars, cyl &gt; 4) tmp &lt;- dplyr::select(tmp, disp) tmp &lt;- head(tmp) # ... more unrelated code Better. mtcars %&gt;% dplyr::filter(cyl &gt; 4) %&gt;% dplyr::select(disp) %&gt;% head() Bad. tmp &lt;- dplyr::filter(mtcars, cyl &gt; 4) tmp &lt;- dplyr::select(tmp, disp) # ... more unrelated code (makes your forget what `tmp` holds) tmp &lt;- head(tmp) 15.6.4 If possible, extract functions to the top level Good. f &lt;- function(x) { g(x) } g &lt;- function(x) { x + 1 } Bad. f &lt;- function(x) { g &lt;- function(x) { x + 1 } g(x) } 15.6.5 Extract commented sections into functions Good. f &lt;- function(x) { y &lt;- calculate_y(x) # ... more code } calculate_y &lt;- function(x) { x^x * x/2L # ... more code specifically about calculating y } Bad. f &lt;- function(x) { # calculate y y &lt;- x^x * x/2L # ... more code specifically about calculating y # ... more code } 15.7 Error prone 15.7.1 Avoid hidden arguments: Extract functions with all arguments Good. f &lt;- function(x, y, z) { x + g(y, z) } g &lt;- function(y, z) { y + z } f(1, 1, 1) #&gt; [1] 3 Bad. # Fragile. f &lt;- function(x, y, z) { g &lt;- function(y) { # `z` is outside of the scope of g(). It&#39;s a hidden argument y + z } x + g(y) } f(1, 1, 1) #&gt; [1] 3 # f() breaks when you move g() to the top level f &lt;- function(x, y, z) { x + g(y) } g &lt;- function(y) { y + z } try(f(1, 1, 1)) #&gt; Error in g(y) : object &#39;z&#39; not found 15.7.2 Separate functions, data, and scripts 15.7.3 A non-package project It’s easy for an analyst to maintain a project when functions, data, and scripts are separate. Good. # R/all-functions.R f &lt;- function(data) { # ... some code } # data/all-datasets.R some_data &lt;- readr::read_csv(here::here(&quot;data-raw&quot;, &quot;some_data.csv&quot;)) # script/this-script.R library(tidyverse) source(here::here(&quot;R&quot;, &quot;all-functions.R&quot;)) source(here::here(&quot;data&quot;, &quot;all-datasets.R&quot;)) f(data = some_data) It is error prone to mix functions, data, and scripts. The mess hides inter dependencies that can break your code unexpectedly. Also, this makes it hard for others to reproduce, or understand your code – the maintainance programmer can only view your code through a toilet paper tube. Bad. # sripts-functions-and-data.R library(tidyverse) some_data &lt;- readr::read_csv(here::here(&quot;data-raw&quot;, &quot;some_data.csv&quot;)) f &lt;- function(some_data) { some_data %&gt;% dplyr::select() %&gt;% # ... more code } f(some_data) 15.7.4 A package project When functions, data, and scripts are separate, it’s easy for a developer to transform a project into an R package. Functions go in the R/ directory, raw data in data-raw/, and data in data/. Scripts become examples, tests, and higher level documentation such as README, and the Home and articles pages of the package-website. 15.7.5 if() uses a single TRUE or FALSE x &lt;- c(1, 2) y &lt;- 0L Good # Good if (identical(x, c(1, 2))) { say(identical(x, c(1, 2)), &quot;is what you gave.&quot;) } #&gt; [1] &quot;TRUE is what you gave.&quot; # Bad if (x == c(1, 2)) { say(x == c(1, 2), &quot;is what you gave.&quot;) } #&gt; Warning in if (x == c(1, 2)) {: the condition has length &gt; 1 and only the first #&gt; element will be used #&gt; [1] &quot;TRUE, TRUE is what you gave.&quot; Caveats: https://github.com/2DegreesInvesting/ds-incubator/issues/13 15.7.6 1 is equal to 1L but not identical Careful! 1 == 1L #&gt; [1] TRUE identical(1, 1L) #&gt; [1] FALSE Good this_integer &lt;- 1L if (!identical(this_integer, 1)) &quot;Not the same&quot; else &quot;Wrong result&quot; #&gt; [1] &quot;Not the same&quot; Bad. this_integer &lt;- 1L if (!this_integer == 1) &quot;Not the same&quot; else &quot;Wrong result&quot; #&gt; [1] &quot;Wrong result&quot; 15.8 Style 15.8.1 Limit your code to 80 characters per line For reference, in RStudio you can set a margin column at 80 characters (Tools &gt; Global Options &gt; Code &gt; Show margin &gt; Margin column). Strive to limit your code to 80 characters per line. This fits comfortably on a printed page with a reasonably sized font. If you find yourself running out of room, this is a good indication that you should encapsulate some of the work in a separate function. – https://style.tidyverse.org/syntax.html#long-lines If a function definition runs over multiple lines, indent the second line to where the definition starts. – https://style.tidyverse.org/functions.html#long-lines-1 15.8.2 Names should use only lowercase letters, numbers, and \"_\". Generally, variable names should be nouns and function names should be verbs. Strive for names that are concise and meaningfully! Reserve dots exclusively for the S3 object system. Good. add_row() permute() Bad. row_adder() permutation() https://style.tidyverse.org/syntax.html#object-names https://style.tidyverse.org/functions.html#naming 15.8.3 Avoid T and F as synonyms for TRUE and FALSE Good sum(1, 1, na.rm = TRUE) Bad. sum(1, 1, na.rm = T) TRUE and FALSE are reserved words; T and F are not. T &lt;- &quot;Whatever&quot; T #&gt; [1] &quot;Whatever&quot; # Forbidden try(TRUE &lt;- &quot;Whatever&quot;) #&gt; Error in TRUE &lt;- &quot;Whatever&quot; : #&gt; invalid (do_set) left-hand side to assignment https://www.r-bloggers.com/r-tip-avoid-using-t-and-f-as-synonyms-for-true-and-false/ 15.8.4 Reserve return() to return early Only use return() for early returns. Otherwise, rely on R to return the result of the last evaluated expression https://style.tidyverse.org/functions.html#return 15.8.5 Return invisibly only when the main purpose is a side effect Good. # Main purpose is a side effect: To throw an error if the input is bad check_f &lt;- function(x) { stopifnot(is.numeric(x)) invisible(x) } Good. # Main purpose is not a side effect. Returning visibly f &lt;- function(x) { x + 1 } f(1) #&gt; [1] 2 Bad. # Main purpose is not a side effect. Returning invisibly f &lt;- function(x) { out &lt;- x + 1 } # Returns invisibly f(1) out &lt;- f(1) out #&gt; [1] 2 "]
]
